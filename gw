#!/usr/bin/env bash
# gw - Git Worktree Switcher
# Quickly list, switch, add, and remove git worktrees with autocomplete.

set -euo pipefail

VERSION="1.0.0"

# Colors
BOLD='\033[1m'
DIM='\033[2m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[0;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
RESET='\033[0m'

# ─── Helpers ──────────────────────────────────────────────────────────────────

_ensure_git() {
  if ! git rev-parse --git-dir &>/dev/null; then
    echo -e "${RED}Error:${RESET} Not inside a git repository." >&2
    exit 1
  fi
}

_worktree_list() {
  # Outputs: path | commit | branch (one per line)
  git worktree list --porcelain | awk '
    function flush() {
      if (path != "") {
        if (branch == "") branch = "(detached)"
        print path "|" head "|" branch
      }
      path = ""; head = ""; branch = ""
    }
    /^worktree / { flush(); path = substr($0, 10) }
    /^HEAD /     { head = substr($0, 6, 7) }
    /^branch /   { branch = substr($0, 8); sub("refs/heads/", "", branch) }
    END          { flush() }
  '
}

_worktree_names() {
  # Returns just the directory basenames of each worktree
  _worktree_list | while IFS='|' read -r path _ _; do
    basename "$path"
  done
}

_find_worktree_path() {
  local name="$1"
  _worktree_list | while IFS='|' read -r path _ branch; do
    local base
    base=$(basename "$path")
    if [[ "$base" == "$name" || "$branch" == "$name" ]]; then
      echo "$path"
      return 0
    fi
  done
}

_current_worktree() {
  basename "$(git rev-parse --show-toplevel 2>/dev/null)" 2>/dev/null || echo ""
}

# ─── Commands ─────────────────────────────────────────────────────────────────

cmd_list() {
  _ensure_git
  local current
  current=$(_current_worktree)

  echo -e "${BOLD}Git Worktrees${RESET}"
  echo ""

  _worktree_list | while IFS='|' read -r path commit branch; do
    local name
    name=$(basename "$path")
    local marker="  "
    local name_color="$RESET"

    if [[ "$name" == "$current" ]]; then
      marker="${GREEN}▸${RESET} "
      name_color="$GREEN$BOLD"
    fi

    printf "  %b%-20b ${DIM}%s${RESET}  ${CYAN}%s${RESET}\n" \
      "$marker" "${name_color}${name}${RESET}" "$commit" "$branch"
  done
  echo ""
}

cmd_switch() {
  _ensure_git

  local target="$1"

  if [[ -z "$target" ]]; then
    # Interactive mode: use fzf if available, otherwise numbered list
    if command -v fzf &>/dev/null; then
      target=$(_worktree_names | fzf --prompt="Switch to worktree: " --height=~40% --reverse) || exit 0
    else
      echo -e "${BOLD}Select a worktree:${RESET}"
      echo ""
      local worktrees=()
      local i=1
      _worktree_list | while IFS='|' read -r path commit branch; do
        local name
        name=$(basename "$path")
        local current
        current=$(_current_worktree)
        local marker="  "
        if [[ "$name" == "$current" ]]; then
          marker="${GREEN}▸${RESET} "
        fi
        printf "  %b${DIM}%d)${RESET} %-20s ${DIM}%s${RESET}  ${CYAN}%s${RESET}\n" \
          "$marker" "$i" "$name" "$commit" "$branch"
        worktrees+=("$name")
        ((i++))
      done

      # Re-read into array (subshell workaround)
      mapfile -t worktrees < <(_worktree_names)

      echo ""
      read -rp "  Enter number: " choice
      if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= ${#worktrees[@]} )); then
        target="${worktrees[$((choice - 1))]}"
      else
        echo -e "${RED}Invalid selection.${RESET}" >&2
        exit 1
      fi
    fi
  fi

  local dest
  dest=$(_find_worktree_path "$target")

  if [[ -z "$dest" ]]; then
    echo -e "${RED}Error:${RESET} Worktree '${target}' not found." >&2
    echo -e "${DIM}Available worktrees:${RESET}"
    _worktree_names | sed 's/^/  /'
    exit 1
  fi

  if [[ "$dest" == "$(git rev-parse --show-toplevel 2>/dev/null)" ]]; then
    echo -e "${YELLOW}Already in worktree '${target}'.${RESET}"
    exit 0
  fi

  echo -e "${GREEN}Switching to${RESET} ${BOLD}${target}${RESET} ${DIM}→ ${dest}${RESET}"
  cd "$dest" || exit 1

  # Print a summary of the target worktree
  echo -e "${DIM}Branch:${RESET} $(git branch --show-current 2>/dev/null || echo 'detached')"
  echo -e "${DIM}Status:${RESET} $(git status --short | wc -l | tr -d ' ') changed files"
}

cmd_add() {
  _ensure_git
  local branch="${1:-}"
  local path="${2:-}"

  if [[ -z "$branch" ]]; then
    echo -e "${RED}Usage:${RESET} gw add <branch> [path]" >&2
    echo -e "${DIM}  Creates a new worktree for the given branch.${RESET}" >&2
    exit 1
  fi

  # Default path: sibling directory named after the branch
  if [[ -z "$path" ]]; then
    local root
    root=$(git worktree list --porcelain | head -1 | sed 's/^worktree //')
    local parent
    parent=$(dirname "$root")
    # Sanitize branch name for directory (replace / with -)
    local dir_name
    dir_name=$(echo "$branch" | tr '/' '-')
    path="${parent}/${dir_name}"
  fi

  # Check if branch exists
  if git show-ref --verify --quiet "refs/heads/${branch}" 2>/dev/null; then
    echo -e "${BLUE}Creating worktree${RESET} for existing branch ${BOLD}${branch}${RESET}"
    git worktree add "$path" "$branch"
  else
    echo -e "${BLUE}Creating worktree${RESET} with new branch ${BOLD}${branch}${RESET}"
    git worktree add -b "$branch" "$path"
  fi

  echo -e "${GREEN}✓${RESET} Worktree created at ${DIM}${path}${RESET}"
  echo -e "  Run: ${CYAN}gw ${branch}${RESET} to switch to it"
}

cmd_remove() {
  _ensure_git
  local target="${1:-}"

  if [[ -z "$target" ]]; then
    echo -e "${RED}Usage:${RESET} gw rm <worktree-name>" >&2
    exit 1
  fi

  local dest
  dest=$(_find_worktree_path "$target")

  if [[ -z "$dest" ]]; then
    echo -e "${RED}Error:${RESET} Worktree '${target}' not found." >&2
    exit 1
  fi

  # Don't allow removing the main worktree
  local main_path
  main_path=$(git worktree list --porcelain | head -1 | sed 's/^worktree //')
  if [[ "$dest" == "$main_path" ]]; then
    echo -e "${RED}Error:${RESET} Cannot remove the main worktree." >&2
    exit 1
  fi

  echo -e "${YELLOW}Removing worktree${RESET} ${BOLD}${target}${RESET} ${DIM}(${dest})${RESET}"
  read -rp "  Are you sure? [y/N] " confirm
  if [[ "$confirm" =~ ^[Yy]$ ]]; then
    git worktree remove "$dest"
    echo -e "${GREEN}✓${RESET} Worktree removed."
  else
    echo -e "${DIM}Cancelled.${RESET}"
  fi
}

cmd_help() {
  cat <<EOF
$(echo -e "${BOLD}gw${RESET} - Git Worktree Switcher ${DIM}v${VERSION}${RESET}")

$(echo -e "${BOLD}USAGE${RESET}")
  gw                      List all worktrees (default)
  gw <name>               Switch to a worktree by name or branch
  gw ls                   List all worktrees
  gw add <branch> [path]  Create a new worktree
  gw rm <name>            Remove a worktree
  gw help                 Show this help

$(echo -e "${BOLD}EXAMPLES${RESET}")
  gw feature-auth         Switch to the 'feature-auth' worktree
  gw add feat/payments    Create worktree for feat/payments branch
  gw rm old-experiment    Remove the old-experiment worktree

$(echo -e "${BOLD}TIPS${RESET}")
  • Tab completion works for worktree names (bash & zsh)
  • If fzf is installed, 'gw switch' opens an interactive picker
  • Worktrees are matched by directory name or branch name

EOF
}

# ─── Main ─────────────────────────────────────────────────────────────────────

main() {
  local cmd="${1:-}"

  case "$cmd" in
    ""|ls|list)
      cmd_list
      ;;
    add|new)
      shift
      cmd_add "$@"
      ;;
    rm|remove|delete)
      shift
      cmd_remove "$@"
      ;;
    help|--help|-h)
      cmd_help
      ;;
    --version|-v)
      echo "gw v${VERSION}"
      ;;
    --completions)
      # Used internally by completion scripts
      _ensure_git
      _worktree_names
      ;;
    --find-path)
      # Used by shell function wrapper to get worktree path for cd
      _ensure_git
      _find_worktree_path "${2:-}"
      ;;
    *)
      # Treat as a switch target
      cmd_switch "$cmd"
      ;;
  esac
}

# If the script is being sourced (for `cd` to work in current shell), export the function
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
  # Sourced mode — define as a function so `cd` persists
  gw() { main "$@"; }
  export -f gw 2>/dev/null || true
else
  main "$@"
fi
